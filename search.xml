<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2F2019%2F07%2F17%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[网络协议 首先要了解网络协议的物理设备是怎么工作的两台电脑要互联，通过网线将电脑a和b的网口（usb）相连 集线器如何有多台电脑，每个电脑只有一个网口，如何相连呢？于是有了集线器，起到了一个将网线集结起来的作用，实现最初级的网络互通 交换机然而集线器有一个问题，由于和每台设备相连，他不能分辨出具体信息是发送给谁的，只能广泛地广播出去。比如a想发给c，结果b，d，e。。。都收到了消息。所以我们给这台设备加入一个指令，让他可以根据网口名称自动寻址传输数据。比如我把A的网口命名为macA，将C的命名为macC，这时如果A想要将数据传给C，则设备会根据网口名称macA和macC自动将资料从A的电脑传送到C的电脑中，而不让B、D和E收到。（这里的macA, macB指的就是MAC地址）也就是说，这台设备解决了冲突的问题，实现了任意两台电脑间的互联，大大地提升了网络间的传输速度，我们把它叫做交换机。 路由器为了保证不同地方能通信，需要采用同样的信息传送形式，信息经协议加工成统一形式，再经由一个特殊的设备传送出去。这个设备就叫做路由器。在这套协议中，每个机器都被赋予了一个IP地址，相当于一个门牌号一样。路由器通过IP地址寻址，我们说它工作在计算机的网络层。这一套协议便是TCP/IP协议簇，互联网也便这样形成了。 五层模型互联网的实现，分成好几层。每一层都有自己的功能： 应用层（Application Layer) 传输层（Transport Layer） 网络层（Network Layer） 链接层（Link Layer） 实体层（Physical Layer） 每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。大家都遵守的规则，就叫做”协议”（protocol）。互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。 实体层电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 链接层定义单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，确定了0和1的分组方式。 以太网协议早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。MAC地址上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。广播首先：一块网卡怎么会知道另一块网卡的MAC地址？回答是有一种ARP协议，可以解决这个问题。其次：就算有了MAC地址，系统怎样才能把数据包准确送到接收方？回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。 有了数据包的定义、网卡的MAC地址、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。 网络层网络层的由来以太网协议，依靠MAC地址发送数据。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。 但是，这样做有一个重大的缺点。以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。 互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。 这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。 网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 IP协议规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。目前，广泛采用的是IP协议第四版，简称IPv4。IPv4这个版本规定，网络地址由32个二进制位组成习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。 互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。 但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。 那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。 所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。 知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。 比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。 总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。 IP数据包IP数据包也分为”标头”和”数据”两个部分“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。放在以太网数据包的data内 ARP协议关于”网络层”，还有最后一点需要说明。因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。 所以，我们需要一种机制，能够从IP地址得到MAC地址。 这里又可以分成两种情况： 1）第一种情况：如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理；2）第二种情况：如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 传输层传输层的由来有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。 接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？ 也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 “端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。 “传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。 UDP协议UDP数据包，也是由”标头”和”数据”两部分组成“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。TCP协议UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。 因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。 TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。 应用层应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。”应用层”的作用，就是规定应用程序的数据格式。 举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样： 网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。发送这个包，需要知道两个地址： 对方的MAC地址； 对方的IP地址。有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。 用户的上网设置 本机的IP地址； 子网掩码； 网关的IP地址； DNS的IP地址。 动态IP地址所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做DHCP协议。 这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。 前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？DHCP协议做了一些巧妙的规定。DHCP协议首先，它是一种应用层协议，建立在UDP协议之上，1）最前面的”以太网标头”：设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。2）后面的”IP标头”：设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。3）最后的”UDP标头”：设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。 接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。 新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。DNS协议我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。子网掩码接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。 已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。 因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sort]]></title>
    <url>%2F2019%2F07%2F16%2Fsort%2F</url>
    <content type="text"><![CDATA[算法 冒泡排序比较相邻的元素。如果第一个比第二个大，就交换它们两个 12345678910111213public static void main(String[] args) &#123; int[] ar = &#123;10,36,3,5,15,7,88,55,30,21,77,58&#125;; for (int i = 0; i &lt; ar.length-1; i++) &#123; for (int j=0;j&lt;ar.length-1-i;j++)&#123; int a=ar[j+1]; if(ar[j]&gt;ar[j+1])&#123; ar[j+1]=ar[j]; ar[j]=a; &#125; &#125; &#125; System.out.println(Arrays.toString(ar));&#125; 最佳情况：T(n) = O(n) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 选择排序首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 1234567891011121314151617public static void main(String[] args) &#123; int[] ar = &#123;10, 36, 3, 5, 15, 7, 88, 55, 30, 21, 77, 58&#125;; for (int i = 0; i &lt; ar.length; i++) &#123; int minIndex = i; for (int j = i; j &lt; ar.length; j++) &#123; if (ar[j] &lt; ar[minIndex]) &#123; minIndex = j; &#125; &#125; int temp = ar[minIndex]; ar[minIndex] = ar[i]; ar[i] = temp; &#125; System.out.println( Arrays.toString( ar ) );&#125; 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 插入排序1从第一个元素开始，该元素可以认为已经被排序；2取出下一个元素，在已经排序的元素序列中从后向前扫描；3如果该元素（已排序）大于新元素，将该元素移到下一位置；4重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；5将新元素插入到该位置后；重复步骤2~5。 123456789101112131415public static void main(String[] args) &#123; int[] ar = &#123;10, 36, 3, 5, 15, 7, 88, 55, 30, 21, 77, 58&#125;; int temp; for (int i = 1; i &lt; ar.length; i++) &#123; temp = ar[i]; while (i&gt;0&amp;&amp;ar[i - 1] &gt; temp) &#123; ar[i] = ar[i - 1]; i--; &#125; ar[i] = temp; &#125; System.out.println( Arrays.toString( ar ) );&#125; 最佳情况：T(n) = O(n) 最坏情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 希尔排序希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。 12345678910111213141516171819public static void main(String[] args) &#123; int[] array = &#123;10, 36, 3, 5, 15, 7, 88, 55, 30, 21, 77, 58&#125;; int len = array.length; int temp, gap = len / 2; while (gap &gt; 0) &#123; for (int i = gap; i &lt; len; i++) &#123; temp = array[i]; int preIndex = i - gap; while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) &#123; array[preIndex + gap] = array[preIndex]; preIndex -= gap; &#125; array[preIndex + gap] = temp; &#125; gap /= 2; &#125; System.out.println( Arrays.toString( array ) );&#125; *最佳情况：T(n) = O(nlog2 n) 最坏情况：T(n) = O(nlog2 n) 平均情况：T(n) =O(nlog2n) * 快速排序通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 快速排序方法 * @param array * @param start * @param end * @return */ public static int[] QuickSort(int[] array, int start, int end) &#123; if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null; int smallIndex = partition(array, start, end); if (smallIndex &gt; start) QuickSort(array, start, smallIndex - 1); if (smallIndex &lt; end) QuickSort(array, smallIndex + 1, end); return array; &#125; /** * 快速排序算法——partition * @param array * @param start * @param end * @return */ public static int partition(int[] array, int start, int end) &#123; int pivot = (int) (start + Math.random() * (end - start + 1)); int smallIndex = start - 1; swap(array, pivot, end); for (int i = start; i &lt;= end; i++) if (array[i] &lt;= array[end]) &#123; smallIndex++; if (i &gt; smallIndex) swap(array, i, smallIndex); &#125; return smallIndex; &#125; /** * 交换数组内两个元素 * @param array * @param i * @param j */ public static void swap(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; *最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(nlogn) *]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['springboot启动']]></title>
    <url>%2F2019%2F07%2F10%2Fspringboot%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[一、springboot启动原理 springboot项目都会用到这个类： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 最关键的是 @SpringBootApplication注解和SpringApplication.run()方法 两点 @SpringBootApplication注解它其实是由多个注解组成的 1234567891011@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;...&#125; 前4个注解是元注解作用为： 123456789101112131415161718192021222324252627/** * Java四大元注解： * 1.@Target ：用于描述注解的使用范围，也就是说使用了@Target去定义一个注解，那么可以决定定义好的注解能用在什么地方 * 内部值：ElementType[] value()数组， value值类型 ElementType枚举类型 * 元注解中的枚举值决定了，一个注解可以标记的范围 * TYPE ： 类型上面 用于描述类、接口(包括注解类型) 或enum声明 * FIELD ： 用于描述字段 * METHOD ：方法 * PARAMETER ： 参数 【参数名】 * CONSTRUCTOR ： 构造方法 * LOCAL_VARIABLE ： 局部变量 * ANNOTATION_TYPE ： 可以打在注解上面 * PACKAGE ：可以打在包上面 * TYPE_PARAMETER ： 参数类型【形式参数类型】 * TYPE_USE ： 任何位置都可以 * 2.@Retention：用于描述一个注解存在的生命周期【源码，字节码文件，运行时】 * 内部值：RetentionPolicy value();非数组，意味着只能一个值： * 值类型：枚举值RetentionPolicy：几个值决定了几个状态：如下几个值 * SOURCE ：表示一个注解可以存在于源码中==&gt;java的源码中 * CLASS ：表示 一个注解可以在源码中，并且可以在字节码文件中 * RUNTIME ：表示 一个注解可以在源码、字节码、及运行时期该注解都会存在 * 3.@Document ：表示该注解是否可以生成到 API文档中 ==》即生成API文档的时 检验 * 4.@Inherited ：表示一个【注解】能够被继承 * 不是说注解与注解之间能否相互继承 * 而是说：一个类A被注解了，那么另外一个类B，继承了A类 * B类能够继承到A类中，的注解 (即被@Inherited注解过的注解) 实际重要的有3个 @SpringBootConfiguration 其实还是使用了 @Configuration @ComponentScan @EnableAutoConfiguration @Configuration1234567@Configurationpublic class MockConfiguration&#123; @Bean public MockService mockService()&#123; return new MockServiceImpl(); &#125;&#125; 任何一个标注了@Configuration的Java类定义都是一个JavaConfig配置类任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id @ComponentScan123@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;) 用于类或接口上主要是指定扫描路径，spring会把指定路径下带有指定注解的类自动装配到bean容器里。会被自动装配的注解包括@Controller、@Service、@Component、@Repository等等常用属性如下： basePackages、value：指定扫描路径，如果为空则以@ComponentScan注解的类所在的包为基本的扫描路径 basePackageClasses：指定具体扫描的类 includeFilters：指定满足Filter条件的类 excludeFilters：指定排除Filter条件的类includeFilters和excludeFilters 的FilterType可选：ANNOTATION=注解类型 默认、ASSIGNABLE_TYPE(指定固定类)、ASPECTJ(ASPECTJ类型)、REGEX(正则表达式)、CUSTOM(自定义类型)，自定义的Filter需要实现TypeFilter接口 @EnableAutoConfiguration12345678910@SuppressWarnings(&quot;deprecation&quot;)@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ...&#125; 其中，最关键的要属@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。 @EnableAutoConfiguration自动配置变成了：从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。 二、SpringApplication执行流程 启动流程： 每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run() 启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，@SpringBootApplication包括三个注解，功能如下： @EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置。 @SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境。 @ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下。 SpringBoot启动类首先进入run方法 1234public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) &#123; return new SpringApplication(primarySources).run(args);&#125; run方法中去创建了一个SpringApplication实例，然后执行run方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445public ConfigurableApplicationContext run(String... args) &#123; StopWatch stopWatch = new StopWatch(); stopWatch.start(); ConfigurableApplicationContext context = null; Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList&lt;&gt;(); configureHeadlessProperty(); SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); try &#123; ApplicationArguments applicationArguments = new DefaultApplicationArguments( args); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); Banner printedBanner = printBanner(environment); context = createApplicationContext(); exceptionReporters = getSpringFactoriesInstances( SpringBootExceptionReporter.class, new Class[] &#123; ConfigurableApplicationContext.class &#125;, context); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) &#123; new StartupInfoLogger(this.mainApplicationClass) .logStarted(getApplicationLog(), stopWatch); &#125; listeners.started(context); callRunners(context, applicationArguments); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, listeners); throw new IllegalStateException(ex); &#125; try &#123; listeners.running(context); &#125; catch (Throwable ex) &#123; handleRunFailure(context, ex, exceptionReporters, null); throw new IllegalStateException(ex); &#125; return context;&#125; 该方法中实现了如下几个关键步骤：1.创建了应用的监听器SpringApplicationRunListeners并开始监听2.加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment3.配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)创建方法： 123456789101112131415161718192021222324protected ConfigurableApplicationContext createApplicationContext() &#123; Class&lt;?&gt; contextClass = this.applicationContextClass; if (contextClass == null) &#123; try &#123; switch (this.webApplicationType) &#123; case SERVLET: contextClass = Class.forName(DEFAULT_WEB_CONTEXT_CLASS); break; case REACTIVE: contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS); break; default: contextClass = Class.forName(DEFAULT_CONTEXT_CLASS); &#125; &#125; catch (ClassNotFoundException ex) &#123; throw new IllegalStateException( &quot;Unable create a default ApplicationContext, &quot; + &quot;please specify an ApplicationContextClass&quot;, ex); &#125; &#125; return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);&#125; 方法会先获取显式设置的应用上下文(applicationContextClass)，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回。5.回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联6.接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成 SpringBoot自动配置模块该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal]]></title>
    <url>%2F2019%2F07%2F08%2FThreadLocal%2F</url>
    <content type="text"><![CDATA[ThreadLocal 什么是threadlocal：提供线程内的局部变量，在多线程情况下保证各个线程的threadlocal变量各自独立。 用途：1、多线程环境下对非线程安全对象的并发访问，而且该对象不需要在线程间共享，可以使用ThreadLocal来使得每个线程都持有一个该对象的副本。2、复杂逻辑下的对象传递 原理： 每个Thread线程内部都有一个Map。Map里面存储线程本地对象（key）和线程的变量副本（value）但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。 Hash冲突怎么解决和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。 每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。ThreadLocal内部的ThreadLocalMap键为弱引用，会有内存泄漏的风险。适用于无状态，副本变量独立后不影响业务逻辑的高并发场景。如果如果业务逻辑强依赖于副本变量，则不适合用ThreadLocal解决，需要另寻解决方案。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础学习]]></title>
    <url>%2F2019%2F06%2F26%2Fjava%2F</url>
    <content type="text"><![CDATA[java基础学习（持续更新）java基础学习 为什么重写equals时必须重写hashCode方法？Object.hashCode的通用约定：如果两个对象根据equals(Object)方法是相等的，那么调用这两个对象中任一个对象的hashCode方法必须产生同样的整数结果。如果只重写了equals，s1.equals(s2)返回true。原生的hashCode值是根据内存地址换算出来的一个值。s1 s2的hashcode必然不相同，违背了上面的约定。对于HashSet和HashMap这些基于散列值（hash）实现的类，数组的下标是根据传入的元素hashCode方法的返回值再和特定的值异或决定的，如果不重写hashCode的话，可能导致HashSet、HashMap不能正常的运作。 为什么Java中只有值传递？值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。 123456789101112public static void main(String[] args) &#123; ParamTest pt = new ParamTest(); int i = 10; pt.pass(i ); System.out.println(&quot;print in main , i is &quot; + i);&#125;public void pass(int j) &#123; j = 20; System.out.println(&quot;print in pass , j is &quot; + j);&#125; 12print in pass , j is 20print in main , i is 10 pass方法内部对name的值的修改并没有改变实际参数i的值。 特殊情况 1234567891011121314public static void main(String[] args) &#123; ParamTest pt = new ParamTest(); User hollis = new User(); hollis.setName(&quot;Hollis&quot;); hollis.setGender(&quot;Male&quot;); pt.pass(hollis); System.out.println(&quot;print in main , user is &quot; + hollis);&#125;public void pass(User user) &#123; user.setName(&quot;hollischuang&quot;); System.out.println(&quot;print in pass , user is &quot; + user);&#125; 12print in pass , user is User&#123;name=&apos;hollischuang&apos;, gender=&apos;Male&apos;&#125;print in main , user is User&#123;name=&apos;hollischuang&apos;, gender=&apos;Male&apos;&#125; pass方法执行后，实参的值虽然被改变，其实还是值传递，因为是把实参对象引用的地址当做值传递给了形式参数，并没有对形参本身进行修改，而是修改的形参持有的地址中存储的内容。 第二种特殊情况 123456789101112public static void main(String[] args) &#123; ParamTest pt = new ParamTest(); String name = &quot;Hollis&quot;; pt.pass(name); System.out.println(&quot;print in main , name is &quot; + name);&#125;public void pass(String name) &#123; name = &quot;hollischuang&quot;; System.out.println(&quot;print in pass , name is &quot; + name);&#125; 12print in pass , name is hollischuangprint in main , name is Hollis 这里值没有变是因为直接改变了name的引用的地址，因为这段代码，会new一个String，再把引用交给name，即等价于： 1name = new String(&quot;hollischuang&quot;); 而原来的那个”Hollis”字符串还是由实参持有着的，所以，并没有修改到实际参数的值。 所以，值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参。在判断实参内容有没有受影响的时候，要看传的的是什么，如果你传递的是个地址，那么就看这个地址的变化会不会有影响，而不是看地址指向的对象的变化。 Math.round()当前值+0.5向下取整]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka]]></title>
    <url>%2F2019%2F06%2F25%2Fkafka%2F</url>
    <content type="text"><![CDATA[kafka使用 首先安装zookeeper解压tar -zxvf zookeeper-3.3.6.tar.gz进入到conf目录 拷贝zoo_samle.cfg为zoo.cfg 编辑zoo.cfg文件 #The number of milliseconds of each ticktickTime=2000 #The number of ticks that the initial #synchronization phase can takeinitLimit=10 #The number of ticks that can pass between #sending a request and getting an acknowledgementsyncLimit=5 #the directory where the snapshot is stored.dataDir=/usr/zookeeperdataLogDir=/usr/zookeeper/log #the port at which the clients will connectclientPort=2181 设置环境变量export ZOOKEEPER_INSTALL=/opt/deploy/zookeeper-3.3.6export PATH=$PATH:$ZOOKEEPER_INSTALL/bin zookeeper 启动 zkServer.sh start状态：zkServer.sh status关闭zookeeper服务：zkServer.sh stop重启zookeeper服务：zkServer.sh restart 安装kafka解压tar -xzf kafka_2.9.2-0.8.1.1.tgz 启动bin/kafka-server-start.sh config/server.properties &amp; 创建 topicbin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test 删除bin/kafka-topics.sh –zookeeper localhost:2181 –delete –topic my-replicated-topic 查看创建的topic:bin/kafka-topics.sh –list –zookeeper localhost:2181 发送bin/kafka-console-producer.sh –broker-list localhost:9092 –topic testmessagectrl+c退出发送 读取bin/kafka-console-consumer.sh –zookeeper localhost:2181 –topic test –from-beginning 搭建一个多个broker的集群cp config/server.properties config/server-1.propertiescp config/server.properties config/server-2.properties 在拷贝出的新文件中添加以下参数：broker.id=1port=9093log.dir=/tmp/kafka-logs-1 broker.id=2port=9094log.dir=/tmp/kafka-logs-2 bin/kafka-server-start.sh config/server-1.properties &amp;bin/kafka-server-start.sh config/server-2.properties &amp; 创建一个拥有3个副本的topic:bin/kafka-topics.sh –create –zookeeper localhost:2181 –replication-factor 3 –partitions 1 –topic my-replicated-topic 每个节点的信息bin/kafka-topics.sh –describe –zookeeper localhost:2181 –topic my-replicated-topic springboot集成kafka配置文件中添加 123456789101112131415kafka: bootstrap-servers: ip:9092 producer: retries: 0 batch-size: 16384 buffer-memory: 33554432 key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.apache.kafka.common.serialization.StringSerializer consumer: group-id: test-consumer-group auto-offset-reset: earliest enable-auto-commit: true auto-commit-interval: 100 key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer maven依赖添加 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;/dependency&gt; java类中使用： 12345678910@Autowired private KafkaTemplate&lt;String, String&gt; kafkaTemplate;public void kafkaSend() &#123; Message message = new Message(); message.setId(System.currentTimeMillis()); message.setMsg(UUID.randomUUID().toString()); message.setSendTime(new Date()); log.info(&quot;+++++++++++++++++++++ message = &#123;&#125;&quot;, gson.toJson(message)); kafkaTemplate.send(&quot;test&quot;, gson.toJson(message)); &#125; 123456789101112131415161718@Slf4j@RestControllerpublic class KafkaReceiver &#123; @KafkaListener(topics = &#123;&quot;test&quot;&#125;) public void listen(ConsumerRecord&lt;?, ?&gt; record) &#123; Optional&lt;?&gt; kafkaMessage = Optional.ofNullable(record.value()); if (kafkaMessage.isPresent()) &#123; Object message = kafkaMessage.get(); log.info(&quot;----------------- record =&quot; + record); log.info(&quot;------------------ message =&quot; + message); &#125; &#125;&#125; 遇到的坑：无法连接kafka，因为未配置外网访问，server.properties中修改listeners=PLAINTEXT://:9092advertised.listeners=PLAINTEXT://ip:9092即可 我使用的kafka可视化工具是Kafka Tool，具体安装教程：https://blog.csdn.net/Dongguabai/article/details/86526299]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务及事务隔离级别]]></title>
    <url>%2F2019%2F06%2F22%2Ftransaction%2F</url>
    <content type="text"><![CDATA[事务及事务隔离级别 什么是事务事务的正确执行使得数据库从一种状态转换为另一种状态。ACID原则:ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability） 并发下事务会产生的问题1、脏读 所谓脏读，就是指事务A读到了事务B还没有提交的数据，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务–&gt;取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。 2、不可重复读 所谓不可重复读，就是指在一个事务里面读取了两次某个数据，读出来的数据不一致。还是以银行取钱为例，事务A开启事务–&gt;查出银行卡余额为1000元，此时切换到事务B事务B开启事务–&gt;事务B取走100元–&gt;提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。 3、幻读 所谓幻读，就是指在一个事务里面的操作中发现了未被操作的数据。比如学生信息，事务A开启事务–&gt;修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务–&gt;事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。 事务隔离级别1、READ_UNCOMMITTED 读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用 2、READ_COMMITED 读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读 3、REPEATABLE_READ 重复读取，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决 4、SERLALIZABLE 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了 查看事务隔离级别使用select @@tx_isolation]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口区别]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[抽象类和接口区别 网上很多讲的只是代码上的区别 抽象类：1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。2、抽象方法必须由子类来进行重写。3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。5、子类中的抽象方法不能与父类的抽象方法同名。6、abstract不能与final并列修饰同一个类。7、abstract 不能与private、static、final或native并列修饰同一个方法。 接口:1、个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。3、接口中不存在实现的方法。4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。6、在实现多接口的时候一定要避免方法名的重复。 区别 但是一直不明白，使用场景上有啥区别 设计层面上的区别(1)抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。(2)设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念： 1234abstract class Door &#123; public abstract void open(); public abstract void close();&#125; 或者 1234interface Door &#123; public abstract void open(); public abstract void close();&#125; 但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路： 1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能； 2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。 从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。 1234567891011121314151617181920interface Alram &#123; void alarm();&#125;abstract class Door &#123; void open(); void close();&#125;class AlarmDoor extends Door implements Alarm &#123; void oepn() &#123; //.... &#125; void close() &#123; //.... &#125; void alarm() &#123; //.... &#125;&#125; 什么时候使用抽象类和接口如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['三线程打印ABC三种解法']]></title>
    <url>%2F2019%2F06%2F17%2Fthreadabc%2F</url>
    <content type="text"><![CDATA[三线程打印ABC三种解法 实例化三个线程，一个线程打印a，一个线程打印b，一个线程打印c，三个线程同时执行，要求打印出10个连着的abc。一、通过两个锁(不推荐，可读性和安全性比较差)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.demo.test;/** * 基于两个lock实现连续打印abcabc.... * @author lixiaoxi * */public class TwoLockPrinter implements Runnable &#123; // 打印次数 private static final int PRINT_COUNT = 10; // 前一个线程的打印锁 private final Object fontLock; // 本线程的打印锁 private final Object thisLock; // 打印字符 private final char printChar; public TwoLockPrinter(Object fontLock, Object thisLock, char printChar) &#123; this.fontLock = fontLock; this.thisLock = thisLock; this.printChar = printChar; &#125; @Override public void run() &#123; // 连续打印PRINT_COUNT次 for (int i = 0; i &lt; PRINT_COUNT; i++) &#123; // 获取前一个线程的打印锁 synchronized (fontLock) &#123; // 获取本线程的打印锁 synchronized (thisLock) &#123; //打印字符 System.out.print(printChar); // 通过本线程的打印锁唤醒后面的线程 // notify和notifyall均可,因为同一时刻只有一个线程在等待 thisLock.notify(); &#125; // 不是最后一次则通过fontLock等待被唤醒 // 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁 if(i &lt; PRINT_COUNT - 1)&#123; try &#123; // 通过fontLock等待被唤醒 fontLock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 打印A线程的锁 Object lockA = new Object(); // 打印B线程的锁 Object lockB = new Object(); // 打印C线程的锁 Object lockC = new Object(); // 打印a的线程 Thread threadA = new Thread(new TwoLockPrinter(lockC, lockA, &apos;A&apos;)); // 打印b的线程 Thread threadB = new Thread(new TwoLockPrinter(lockA, lockB, &apos;B&apos;)); // 打印c的线程 Thread threadC = new Thread(new TwoLockPrinter(lockB, lockC, &apos;C&apos;)); // 依次开启a b c线程 threadA.start(); Thread.sleep(100); // 确保按顺序A、B、C执行 threadB.start(); Thread.sleep(100); threadC.start(); Thread.sleep(100); &#125;&#125; 分析：此解法为了为了确定唤醒、等待的顺序，每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是fontLock，就是前一个线程所持有的对象锁，还有一个就是自身对象锁thisLock。主要的思想就是，为了控制执行的顺序，必须要先持有fontLock锁，也就是前一个线程要释放掉前一个线程自身的对象锁，当前线程再去申请自身对象锁，两者兼备时打印，之后首先调用thisLock.notify()释放自身对象锁，唤醒下一个等待线程，再调用fontLock.wait()释放prev对象锁，暂停当前线程，等待再次被唤醒后进入循环。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C，A对象锁，后释放A锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A，B，C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序，所以需要手动控制他们三个的启动顺序，即Thread.Sleep(100)。 二、通过一个ReentrantLock和三个conditon实现(推荐，安全性，性能和可读性较高)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.demo.test;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * 基于一个ReentrantLock和三个conditon实现连续打印abcabc... * @author lixiaoxi * */public class RcSyncPrinter implements Runnable&#123; // 打印次数 private static final int PRINT_COUNT = 10; // 打印锁 private final ReentrantLock reentrantLock; // 本线程打印所需的condition private final Condition thisCondtion; // 下一个线程打印所需要的condition private final Condition nextCondtion; // 打印字符 private final char printChar; public RcSyncPrinter(ReentrantLock reentrantLock, Condition thisCondtion, Condition nextCondition, char printChar) &#123; this.reentrantLock = reentrantLock; this.nextCondtion = nextCondition; this.thisCondtion = thisCondtion; this.printChar = printChar; &#125; @Override public void run() &#123; // 获取打印锁 进入临界区 reentrantLock.lock(); try &#123; // 连续打印PRINT_COUNT次 for (int i = 0; i &lt; PRINT_COUNT; i++) &#123; //打印字符 System.out.print(printChar); // 使用nextCondition唤醒下一个线程 // 因为只有一个线程在等待，所以signal或者signalAll都可以 nextCondtion.signal(); // 不是最后一次则通过thisCondtion等待被唤醒 // 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁 if (i &lt; PRINT_COUNT - 1) &#123; try &#123; // 本线程让出锁并等待唤醒 thisCondtion.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; finally &#123; // 释放打印锁 reentrantLock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 写锁 ReentrantLock lock = new ReentrantLock(); // 打印a线程的condition Condition conditionA = lock.newCondition(); // 打印b线程的condition Condition conditionB = lock.newCondition(); // 打印c线程的condition Condition conditionC = lock.newCondition(); // 实例化A线程 Thread printerA = new Thread(new RcSyncPrinter(lock, conditionA, conditionB, &apos;A&apos;)); // 实例化B线程 Thread printerB = new Thread(new RcSyncPrinter(lock, conditionB, conditionC, &apos;B&apos;)); // 实例化C线程 Thread printerC = new Thread(new RcSyncPrinter(lock, conditionC, conditionA, &apos;C&apos;)); // 依次开始A B C线程 printerA.start(); Thread.sleep(100); printerB.start(); Thread.sleep(100); printerC.start(); &#125;&#125; 分析：仔细想想本问题，既然同一时刻只能有一个线程打印字符，那我们为什么不使用一个同步锁ReentrantLock？线程之间的唤醒操作可以通过Condition实现，且Condition可以有多个，每个condition.await阻塞只能通过该condition的signal/signalall来唤醒！这是synchronized关键字所达不到的，那我们就可以给每个打印线程一个自身的condition和下一个线程的condition，每次打印字符后，调用下一个线程的condition.signal来唤醒下一个线程，然后自身再通过自己的condition.await来释放锁并等待唤醒。 三、通过一个锁和一个状态变量来实现（推荐）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.demo.test;/** * 基于一个锁和一个状态变量实现连续打印abcabc... * @author lixiaoxi * */public class StateLockPrinter &#123; //状态变量 private volatile int state=0; // 打印线程 private class Printer implements Runnable &#123; //打印次数 private static final int PRINT_COUNT=10; //打印锁 private final Object printLock; //打印标志位 和state变量相关 private final int printFlag; //后继线程的线程的打印标志位，state变量相关 private final int nextPrintFlag; //该线程的打印字符 private final char printChar; public Printer(Object printLock, int printFlag,int nextPrintFlag, char printChar) &#123; super(); this.printLock = printLock; this.printFlag=printFlag; this.nextPrintFlag=nextPrintFlag; this.printChar = printChar; &#125; @Override public void run() &#123; //获取打印锁 进入临界区 synchronized (printLock) &#123; //连续打印PRINT_COUNT次 for(int i=0;i&lt;PRINT_COUNT;i++)&#123; //循环检验标志位 每次都阻塞然后等待唤醒 while (state!=printFlag) &#123; try &#123; printLock.wait(); &#125; catch (InterruptedException e) &#123; return; &#125; &#125; //打印字符 System.out.print(printChar); //设置状态变量为下一个线程的标志位 state=nextPrintFlag; //注意要notifyall，不然会死锁，因为notify只通知一个， //但是同时等待的是两个,如果唤醒的不是正确那个就会没人唤醒，死锁了 printLock.notifyAll(); &#125; &#125; &#125; &#125; public void test() throws InterruptedException&#123; //锁 Object lock=new Object(); //打印A的线程 Thread threadA=new Thread(new Printer(lock, 0,1, &apos;A&apos;)); //打印B的线程 Thread threadB=new Thread(new Printer(lock, 1,2, &apos;B&apos;)); //打印C的线程 Thread threadC=new Thread(new Printer(lock, 2,0, &apos;C&apos;)); //一次启动A B C线程 threadA.start(); Thread.sleep(1000); threadB.start(); Thread.sleep(1000); threadC.start(); &#125; public static void main(String[] args) throws InterruptedException &#123; StateLockPrinter print = new StateLockPrinter(); print.test(); &#125; &#125; 分析：状态变量是一个volatile的整型变量，0代表打印a，1代表打印b，2代表打印c，三个线程都循环检验标志位，通过阻塞前和阻塞后两次判断可以确保当前打印的正确顺序，随后线程打印字符，然后设置下一个状态字符，唤醒其它线程，然后重新进入循环。]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程记录]]></title>
    <url>%2F2019%2F06%2F15%2Fthread%2F</url>
    <content type="text"><![CDATA[java线程记录 创建线程和启动（1）继承Thread类创建线程类通过继承Thread类创建线程类的具体步骤和具体代码如下： • 定义一个继承Thread类的子类，并重写该类的run()方法； • 创建Thread子类的实例，即创建了线程对象； • 调用该线程对象的start()方法启动线程。 1234567891011class SomeThead extends Thraad &#123; public void run() &#123; //do something here &#125; &#125; public static void main(String[] args)&#123; SomeThread oneThread = new SomeThread(); 步骤3：启动线程： oneThread.start(); &#125; （2）实现Runnable接口创建线程类通过实现Runnable接口创建线程类的具体步骤和具体代码如下： • 定义Runnable接口的实现类，并重写该接口的run()方法； • 创建Runnable实现类的实例，并以此实例作为Thread的target对象，即该Thread对象才是真正的线程对象。 12345678class SomeRunnable implements Runnable &#123; public void run() &#123; //do something here &#125; &#125; Runnable oneRunnable = new SomeRunnable(); Thread oneThread = new Thread(oneRunnable); oneThread.start(); （3）通过Callable和Future创建线程通过Callable和Future创建线程的具体步骤和具体代码如下： • 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 • 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 • 使用FutureTask对象作为Thread对象的target创建并启动新线程。 • 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值其中，Callable接口(也只有一个方法)定义如下：public interface Callable { V call() throws Exception; } 步骤1：创建实现Callable接口的类SomeCallable(略); 步骤2：创建一个类对象： Callable oneCallable = new SomeCallable(); 步骤3：由Callable创建一个FutureTask对象： FutureTask oneTask = new FutureTask(oneCallable); 注释： FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了 Future和Runnable接口。 步骤4：由FutureTask创建一个Thread对象： Thread oneThread = new Thread(oneTask); 步骤5：启动线程： oneThread.start(); 二、线程的生命周期新建：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。 就绪：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。 运行：执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。 阻塞：执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。 死亡：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程 三、线程管理1、线程睡眠——sleep 如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。睡眠的始终是当前正在运行的线程，而不是调用它的线程对象（wait()会释放对象的同步锁，而sleep()则不会释放锁） 2、线程让步——yield yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态， 而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次， 完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。 注：关于sleep()方法和yield()方的区别如下： ①、sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。 ②、sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常。 ③、sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行。 3、线程合并——joinvoid join() 当前线程等该加入该线程后面，等待该线程终止。void join(long millis) 当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度void join(long millis,int nanos) 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度 4、设置线程的优先级setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级（0~10，用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性） 5、后台（守护）线程 6、正确结束线程Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法： • 正常执行完run方法，然后结束掉； • 控制循环条件和判断条件的标识符来结束掉线程。 四、线程同步1、同步方法 public synchronized void save(){}2、同步代码块 synchronized (this) { count +=money; }3、使用特殊域变量(volatile)实现线程同步• volatile关键字为域变量的访问提供了一种免锁机制； • 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新； • 因此每次使用该域就要重新计算，而不是使用寄存器中的值； • volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。4、使用重入锁（Lock）实现线程同步 五、线程通信1、借助于Object类的wait()、notify()和notifyAll()实现通信 1234567891011121314151617181920212223242526272829303132333435class Resource&#123; private String name; private int count=1; private boolean flag=false; public synchronized void set(String name)&#123; while(flag) /*原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; this.name=name+&quot;---&quot;+count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag=true; this.notifyAll();/*原先是notity(), 现在改成notifyAll(),这样生产者线程生产完一个商品后可以将等待中的消费者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; public synchronized void out()&#123; while(!flag) /*原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); flag=false; this.notifyAll(); /*原先是notity(), 现在改成notifyAll(),这样消费者线程消费完一个商品后可以将等待中的生产者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; &#125; public class ProducerConsumerDemo&#123; public static void main(String[] args)&#123; Resource r=new Resource(); Producer pro=new Producer(r); Consumer con=new Consumer(r); Thread t1=new Thread(pro); Thread t2=new Thread(con); Thread t3=new Thread(pro); Thread t4=new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; 2、使用Condition控制线程通信 jdk1.5中，提供了多线程的升级解决方案为： （1）将同步synchronized替换为显式的Lock操作； （2）将Object类中的wait(), notify(),notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取; （3）一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁 123456789101112131415161718192021222324252627282930313233343536class Resource&#123; private String name; private int count=1; private boolean flag=false; private Lock lock = new ReentrantLock();/*Lock是一个接口，ReentrantLock是该接口的一个直接子类。*/ private Condition condition_pro=lock.newCondition(); /*创建代表生产者方面的Condition对象*/ private Condition condition_con=lock.newCondition(); /*使用同一个锁，创建代表消费者方面的Condition对象*/ public void set(String name)&#123; lock.lock();//锁住此语句与lock.unlock()之间的代码 try&#123; while(flag) condition_pro.await(); //生产者线程在conndition_pro对象上等待 this.name=name+&quot;---&quot;+count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag=true; condition_con.signalAll(); &#125; finally&#123; lock.unlock(); //unlock()要放在finally块中。 &#125; &#125; public void out()&#123; lock.lock(); //锁住此语句与lock.unlock()之间的代码 try&#123; while(!flag) condition_con.await(); //消费者线程在conndition_con对象上等待 System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); flag=false; condition_pro.signqlAll(); /*唤醒所有在condition_pro对象下等待的线程，也就是唤醒所有生产者线程*/ &#125; finally&#123; lock.unlock(); &#125; &#125; &#125; 3、使用阻塞队列（BlockingQueue）控制线程通信 六、线程池newFixedThreadPool() ： 作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。 2、newCachedThreadPool() ： 作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。 3、newSingleThreadExecutor() ： 作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。 4、newScheduledThreadPool() ： 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。 5、newSingleThreadScheduledExecutor() ： 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。 execute(Runnable)这个方法接收一个Runnable实例，并且异步的执行 submit(Runnable)submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕 submit(Callable)submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。 1、Java8增强的ForkJoinPool产生线程池当需要处理递归分治算法时，考虑使用ForkJoinPool；仔细设置不再进行任务划分的阈值，这个阈值对性能有影响；Java 8中的一些特性会使用到ForkJoinPool中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量。 七、死锁（1）死锁的四个必要条件互斥条件：资源不能被共享，只能被同一个进程使用请求与保持条件：已经得到资源的进程可以申请新的资源非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源 线程离开运行状态的3种方法： 1、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。 2、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。 3、调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins]]></title>
    <url>%2F2019%2F06%2F12%2Fjenkins%2F</url>
    <content type="text"><![CDATA[jenkins+github自动部署项目遇到的问题 jenkins重启命令service jenkins restart jenkins构建项目后会杀死字进程解决办法export BUILD_ID=dontKillMenohup java -jar /home/cloud/run/spring-boot-0.0.1-SNAPSHOT.jar &gt;/dev/null 2&gt;&amp;1 &amp;sleep 10s]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis学习]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[刚开始使用redis，记录一些东西，可能有点杂 Redis为什么使用单进程单线程方式也这么快1完全基于内存2采用单线程,避免了不必要的上下文切换和竞争条件3使用多路 I/O 复用模型 redis的内部实现内部实现采用epoll参考文章http://yaocoder.blog.51cto.com/2668309/888374 多路 I/O 复用和多线程IO有什么区别呢1.CPU本来就是线性的不论什么都需要顺序处理并行只能是多核CPU2.跟多线程相比较,线程切换需要切换到内核进行线程切换,需要消耗时间和资源.而I/O多路复用不需要切换线/进程,效率相对较高,特别是对高并发的应用nginx就是用I/O多路复用,故而性能极佳.但多线程编程逻辑和处理上比I/O多路复用简单.而I/O多路复用处理起 IO 多路复用是5种I/O模型中的第3种，对各种模型讲个故事，描述下区别：故事情节为：老李去买火车票，三天后买到一张退票。参演人员（老李，黄牛，售票员，快递员），往返车站耗费1小时。 1.阻塞I/O模型 老李去火车站买票，排队三天买到一张退票。 耗费：在车站吃喝拉撒睡 3天，其他事一件没干。 2.非阻塞I/O模型 老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。 耗费：往返车站6次，路上6小时，其他时间做了好多事。 3.I/O复用模型 1.select/poll 老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次 2.epoll 老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话 4.信号驱动I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话 5.异步I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。 耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话 redisTemplate apihttps://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisTemplate.html#restore-K-byte:A-long-java.util.concurrent.TimeUnit- 还在持续记录中]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
