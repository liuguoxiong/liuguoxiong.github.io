<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[事务及事务隔离级别]]></title>
    <url>%2F2019%2F06%2F22%2Ftransaction%2F</url>
    <content type="text"><![CDATA[事务及事务隔离级别 什么是事务事务的正确执行使得数据库从一种状态转换为另一种状态。ACID原则:ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability） 并发下事务会产生的问题1、脏读 所谓脏读，就是指事务A读到了事务B还没有提交的数据，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务–&gt;取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。 2、不可重复读 所谓不可重复读，就是指在一个事务里面读取了两次某个数据，读出来的数据不一致。还是以银行取钱为例，事务A开启事务–&gt;查出银行卡余额为1000元，此时切换到事务B事务B开启事务–&gt;事务B取走100元–&gt;提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。 3、幻读 所谓幻读，就是指在一个事务里面的操作中发现了未被操作的数据。比如学生信息，事务A开启事务–&gt;修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务–&gt;事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。 事务隔离级别1、READ_UNCOMMITTED 读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用 2、READ_COMMITED 读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读 3、REPEATABLE_READ 重复读取，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决 4、SERLALIZABLE 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了 查看事务隔离级别使用select @@tx_isolation]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口区别]]></title>
    <url>%2F2019%2F06%2F18%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[抽象类和接口区别 网上很多讲的只是代码上的区别 抽象类：1、抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可。2、抽象方法必须由子类来进行重写。3、只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法。4、抽象类中可以包含具体的方法，当然也可以不包含抽象方法。5、子类中的抽象方法不能与父类的抽象方法同名。6、abstract不能与final并列修饰同一个类。7、abstract 不能与private、static、final或native并列修饰同一个方法。 接口:1、个Interface的方所有法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！2、接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。3、接口中不存在实现的方法。4、实现接口的非抽象类必须要实现该接口的所有方法。抽象类可以不用实现。5、不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用（refer to)一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。6、在实现多接口的时候一定要避免方法名的重复。 区别 但是一直不明白，使用场景上有啥区别 设计层面上的区别(1)抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。(2)设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。 下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念： 1234abstract class Door &#123; public abstract void open(); public abstract void close();&#125; 或者 1234interface Door &#123; public abstract void open(); public abstract void close();&#125; 但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路： 1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能； 2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。 从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。 1234567891011121314151617181920interface Alram &#123; void alarm();&#125;abstract class Door &#123; void open(); void close();&#125;class AlarmDoor extends Door implements Alarm &#123; void oepn() &#123; //.... &#125; void close() &#123; //.... &#125; void alarm() &#123; //.... &#125;&#125; 什么时候使用抽象类和接口如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA['三线程打印ABC三种解法']]></title>
    <url>%2F2019%2F06%2F17%2Fthreadabc%2F</url>
    <content type="text"><![CDATA[三线程打印ABC三种解法 实例化三个线程，一个线程打印a，一个线程打印b，一个线程打印c，三个线程同时执行，要求打印出10个连着的abc。一、通过两个锁(不推荐，可读性和安全性比较差)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879package com.demo.test;/** * 基于两个lock实现连续打印abcabc.... * @author lixiaoxi * */public class TwoLockPrinter implements Runnable &#123; // 打印次数 private static final int PRINT_COUNT = 10; // 前一个线程的打印锁 private final Object fontLock; // 本线程的打印锁 private final Object thisLock; // 打印字符 private final char printChar; public TwoLockPrinter(Object fontLock, Object thisLock, char printChar) &#123; this.fontLock = fontLock; this.thisLock = thisLock; this.printChar = printChar; &#125; @Override public void run() &#123; // 连续打印PRINT_COUNT次 for (int i = 0; i &lt; PRINT_COUNT; i++) &#123; // 获取前一个线程的打印锁 synchronized (fontLock) &#123; // 获取本线程的打印锁 synchronized (thisLock) &#123; //打印字符 System.out.print(printChar); // 通过本线程的打印锁唤醒后面的线程 // notify和notifyall均可,因为同一时刻只有一个线程在等待 thisLock.notify(); &#125; // 不是最后一次则通过fontLock等待被唤醒 // 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁 if(i &lt; PRINT_COUNT - 1)&#123; try &#123; // 通过fontLock等待被唤醒 fontLock.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 打印A线程的锁 Object lockA = new Object(); // 打印B线程的锁 Object lockB = new Object(); // 打印C线程的锁 Object lockC = new Object(); // 打印a的线程 Thread threadA = new Thread(new TwoLockPrinter(lockC, lockA, &apos;A&apos;)); // 打印b的线程 Thread threadB = new Thread(new TwoLockPrinter(lockA, lockB, &apos;B&apos;)); // 打印c的线程 Thread threadC = new Thread(new TwoLockPrinter(lockB, lockC, &apos;C&apos;)); // 依次开启a b c线程 threadA.start(); Thread.sleep(100); // 确保按顺序A、B、C执行 threadB.start(); Thread.sleep(100); threadC.start(); Thread.sleep(100); &#125;&#125; 分析：此解法为了为了确定唤醒、等待的顺序，每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是fontLock，就是前一个线程所持有的对象锁，还有一个就是自身对象锁thisLock。主要的思想就是，为了控制执行的顺序，必须要先持有fontLock锁，也就是前一个线程要释放掉前一个线程自身的对象锁，当前线程再去申请自身对象锁，两者兼备时打印，之后首先调用thisLock.notify()释放自身对象锁，唤醒下一个等待线程，再调用fontLock.wait()释放prev对象锁，暂停当前线程，等待再次被唤醒后进入循环。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C，A对象锁，后释放A锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A，B，C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序，所以需要手动控制他们三个的启动顺序，即Thread.Sleep(100)。 二、通过一个ReentrantLock和三个conditon实现(推荐，安全性，性能和可读性较高)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.demo.test;import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;/** * 基于一个ReentrantLock和三个conditon实现连续打印abcabc... * @author lixiaoxi * */public class RcSyncPrinter implements Runnable&#123; // 打印次数 private static final int PRINT_COUNT = 10; // 打印锁 private final ReentrantLock reentrantLock; // 本线程打印所需的condition private final Condition thisCondtion; // 下一个线程打印所需要的condition private final Condition nextCondtion; // 打印字符 private final char printChar; public RcSyncPrinter(ReentrantLock reentrantLock, Condition thisCondtion, Condition nextCondition, char printChar) &#123; this.reentrantLock = reentrantLock; this.nextCondtion = nextCondition; this.thisCondtion = thisCondtion; this.printChar = printChar; &#125; @Override public void run() &#123; // 获取打印锁 进入临界区 reentrantLock.lock(); try &#123; // 连续打印PRINT_COUNT次 for (int i = 0; i &lt; PRINT_COUNT; i++) &#123; //打印字符 System.out.print(printChar); // 使用nextCondition唤醒下一个线程 // 因为只有一个线程在等待，所以signal或者signalAll都可以 nextCondtion.signal(); // 不是最后一次则通过thisCondtion等待被唤醒 // 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁 if (i &lt; PRINT_COUNT - 1) &#123; try &#123; // 本线程让出锁并等待唤醒 thisCondtion.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; finally &#123; // 释放打印锁 reentrantLock.unlock(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; // 写锁 ReentrantLock lock = new ReentrantLock(); // 打印a线程的condition Condition conditionA = lock.newCondition(); // 打印b线程的condition Condition conditionB = lock.newCondition(); // 打印c线程的condition Condition conditionC = lock.newCondition(); // 实例化A线程 Thread printerA = new Thread(new RcSyncPrinter(lock, conditionA, conditionB, &apos;A&apos;)); // 实例化B线程 Thread printerB = new Thread(new RcSyncPrinter(lock, conditionB, conditionC, &apos;B&apos;)); // 实例化C线程 Thread printerC = new Thread(new RcSyncPrinter(lock, conditionC, conditionA, &apos;C&apos;)); // 依次开始A B C线程 printerA.start(); Thread.sleep(100); printerB.start(); Thread.sleep(100); printerC.start(); &#125;&#125; 分析：仔细想想本问题，既然同一时刻只能有一个线程打印字符，那我们为什么不使用一个同步锁ReentrantLock？线程之间的唤醒操作可以通过Condition实现，且Condition可以有多个，每个condition.await阻塞只能通过该condition的signal/signalall来唤醒！这是synchronized关键字所达不到的，那我们就可以给每个打印线程一个自身的condition和下一个线程的condition，每次打印字符后，调用下一个线程的condition.signal来唤醒下一个线程，然后自身再通过自己的condition.await来释放锁并等待唤醒。 三、通过一个锁和一个状态变量来实现（推荐）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.demo.test;/** * 基于一个锁和一个状态变量实现连续打印abcabc... * @author lixiaoxi * */public class StateLockPrinter &#123; //状态变量 private volatile int state=0; // 打印线程 private class Printer implements Runnable &#123; //打印次数 private static final int PRINT_COUNT=10; //打印锁 private final Object printLock; //打印标志位 和state变量相关 private final int printFlag; //后继线程的线程的打印标志位，state变量相关 private final int nextPrintFlag; //该线程的打印字符 private final char printChar; public Printer(Object printLock, int printFlag,int nextPrintFlag, char printChar) &#123; super(); this.printLock = printLock; this.printFlag=printFlag; this.nextPrintFlag=nextPrintFlag; this.printChar = printChar; &#125; @Override public void run() &#123; //获取打印锁 进入临界区 synchronized (printLock) &#123; //连续打印PRINT_COUNT次 for(int i=0;i&lt;PRINT_COUNT;i++)&#123; //循环检验标志位 每次都阻塞然后等待唤醒 while (state!=printFlag) &#123; try &#123; printLock.wait(); &#125; catch (InterruptedException e) &#123; return; &#125; &#125; //打印字符 System.out.print(printChar); //设置状态变量为下一个线程的标志位 state=nextPrintFlag; //注意要notifyall，不然会死锁，因为notify只通知一个， //但是同时等待的是两个,如果唤醒的不是正确那个就会没人唤醒，死锁了 printLock.notifyAll(); &#125; &#125; &#125; &#125; public void test() throws InterruptedException&#123; //锁 Object lock=new Object(); //打印A的线程 Thread threadA=new Thread(new Printer(lock, 0,1, &apos;A&apos;)); //打印B的线程 Thread threadB=new Thread(new Printer(lock, 1,2, &apos;B&apos;)); //打印C的线程 Thread threadC=new Thread(new Printer(lock, 2,0, &apos;C&apos;)); //一次启动A B C线程 threadA.start(); Thread.sleep(1000); threadB.start(); Thread.sleep(1000); threadC.start(); &#125; public static void main(String[] args) throws InterruptedException &#123; StateLockPrinter print = new StateLockPrinter(); print.test(); &#125; &#125; 分析：状态变量是一个volatile的整型变量，0代表打印a，1代表打印b，2代表打印c，三个线程都循环检验标志位，通过阻塞前和阻塞后两次判断可以确保当前打印的正确顺序，随后线程打印字符，然后设置下一个状态字符，唤醒其它线程，然后重新进入循环。]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java线程记录]]></title>
    <url>%2F2019%2F06%2F15%2Fthread%2F</url>
    <content type="text"><![CDATA[java线程记录 创建线程和启动（1）继承Thread类创建线程类通过继承Thread类创建线程类的具体步骤和具体代码如下： • 定义一个继承Thread类的子类，并重写该类的run()方法； • 创建Thread子类的实例，即创建了线程对象； • 调用该线程对象的start()方法启动线程。 1234567891011class SomeThead extends Thraad &#123; public void run() &#123; //do something here &#125; &#125; public static void main(String[] args)&#123; SomeThread oneThread = new SomeThread(); 步骤3：启动线程： oneThread.start(); &#125; （2）实现Runnable接口创建线程类通过实现Runnable接口创建线程类的具体步骤和具体代码如下： • 定义Runnable接口的实现类，并重写该接口的run()方法； • 创建Runnable实现类的实例，并以此实例作为Thread的target对象，即该Thread对象才是真正的线程对象。 12345678class SomeRunnable implements Runnable &#123; public void run() &#123; //do something here &#125; &#125; Runnable oneRunnable = new SomeRunnable(); Thread oneThread = new Thread(oneRunnable); oneThread.start(); （3）通过Callable和Future创建线程通过Callable和Future创建线程的具体步骤和具体代码如下： • 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 • 创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 • 使用FutureTask对象作为Thread对象的target创建并启动新线程。 • 调用FutureTask对象的get()方法来获得子线程执行结束后的返回值其中，Callable接口(也只有一个方法)定义如下：public interface Callable { V call() throws Exception; } 步骤1：创建实现Callable接口的类SomeCallable(略); 步骤2：创建一个类对象： Callable oneCallable = new SomeCallable(); 步骤3：由Callable创建一个FutureTask对象： FutureTask oneTask = new FutureTask(oneCallable); 注释： FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了 Future和Runnable接口。 步骤4：由FutureTask创建一个Thread对象： Thread oneThread = new Thread(oneTask); 步骤5：启动线程： oneThread.start(); 二、线程的生命周期新建：用new关键字和Thread类或其子类建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态（runnable）。 就绪：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU。等待状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会从等待执行状态进入执行状态，系统挑选的动作称之为“cpu调度”。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。 运行：执行run()方法中的任务。如果该线程失去了cpu资源，就会又从运行状态变为就绪状态。重新等待系统分配资源。也可以对在运行状态的线程调用yield()方法，它就会让出cpu资源，再次变为就绪状态。 阻塞：执行了sleep（睡眠）方法，或等待I/O设备等资源，将让出CPU并暂时停止自己的运行，进入阻塞状态。在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行。 死亡：当线程的run()方法执行完，或者被强制性地终止，就认为它死去。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程 三、线程管理1、线程睡眠——sleep 如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。睡眠的始终是当前正在运行的线程，而不是调用它的线程对象（wait()会释放对象的同步锁，而sleep()则不会释放锁） 2、线程让步——yield yield()方法和sleep()方法有点相似，它也是Thread类提供的一个静态的方法，它也可以让当前正在执行的线程暂停，让出cpu资源给其他的线程。但是和sleep()方法不同的是，它不会进入到阻塞状态， 而是进入到就绪状态。yield()方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次， 完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。 注：关于sleep()方法和yield()方的区别如下： ①、sleep方法暂停当前线程后，会进入阻塞状态，只有当睡眠时间到了，才会转入就绪状态。而yield方法调用后 ，是直接进入就绪状态，所以有可能刚进入就绪状态，又被调度到运行状态。 ②、sleep方法声明抛出了InterruptedException，所以调用sleep方法的时候要捕获该异常，或者显示声明抛出该异常。而yield方法则没有声明抛出任务异常。 ③、sleep方法比yield方法有更好的可移植性，通常不要依靠yield方法来控制并发线程的执行。 3、线程合并——joinvoid join() 当前线程等该加入该线程后面，等待该线程终止。void join(long millis) 当前线程等待该线程终止的时间最长为 millis 毫秒。 如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度void join(long millis,int nanos) 等待该线程终止的时间最长为 millis 毫秒 + nanos 纳秒。如果在millis时间内，该线程没有执行完，那么当前线程进入就绪状态，重新等待cpu调度 4、设置线程的优先级setPriority(int newPriority)和getPriority()方法来设置和返回一个指定线程的优先级（0~10，用MAX_PRIORITY、MIN_PRIORITY和NORM_PRIORITY三个静态常量来设定优先级，这样才能保证程序最好的可移植性） 5、后台（守护）线程 6、正确结束线程Thread.stop()、Thread.suspend、Thread.resume、Runtime.runFinalizersOnExit这些终止线程运行的方法已经被废弃了，使用它们是极端不安全的！想要安全有效的结束一个线程，可以使用下面的方法： • 正常执行完run方法，然后结束掉； • 控制循环条件和判断条件的标识符来结束掉线程。 四、线程同步1、同步方法 public synchronized void save(){}2、同步代码块 synchronized (this) { count +=money; }3、使用特殊域变量(volatile)实现线程同步• volatile关键字为域变量的访问提供了一种免锁机制； • 使用volatile修饰域相当于告诉虚拟机该域可能会被其他线程更新； • 因此每次使用该域就要重新计算，而不是使用寄存器中的值； • volatile不会提供任何原子操作，它也不能用来修饰final类型的变量。4、使用重入锁（Lock）实现线程同步 五、线程通信1、借助于Object类的wait()、notify()和notifyAll()实现通信 1234567891011121314151617181920212223242526272829303132333435class Resource&#123; private String name; private int count=1; private boolean flag=false; public synchronized void set(String name)&#123; while(flag) /*原先是if,现在改成while，这样生产者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; this.name=name+&quot;---&quot;+count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag=true; this.notifyAll();/*原先是notity(), 现在改成notifyAll(),这样生产者线程生产完一个商品后可以将等待中的消费者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; public synchronized void out()&#123; while(!flag) /*原先是if,现在改成while，这样消费者线程从冻结状态醒来时，还会再判断flag.*/ try&#123;wait();&#125;catch(Exception e)&#123;&#125; System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); flag=false; this.notifyAll(); /*原先是notity(), 现在改成notifyAll(),这样消费者线程消费完一个商品后可以将等待中的生产者线程唤醒，否则只将上面改成while后，可能出现所有生产者和消费者都在wait()的情况。*/ &#125; &#125; public class ProducerConsumerDemo&#123; public static void main(String[] args)&#123; Resource r=new Resource(); Producer pro=new Producer(r); Consumer con=new Consumer(r); Thread t1=new Thread(pro); Thread t2=new Thread(con); Thread t3=new Thread(pro); Thread t4=new Thread(con); t1.start(); t2.start(); t3.start(); t4.start(); &#125; &#125; 2、使用Condition控制线程通信 jdk1.5中，提供了多线程的升级解决方案为： （1）将同步synchronized替换为显式的Lock操作； （2）将Object类中的wait(), notify(),notifyAll()替换成了Condition对象，该对象可以通过Lock锁对象获取; （3）一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁 123456789101112131415161718192021222324252627282930313233343536class Resource&#123; private String name; private int count=1; private boolean flag=false; private Lock lock = new ReentrantLock();/*Lock是一个接口，ReentrantLock是该接口的一个直接子类。*/ private Condition condition_pro=lock.newCondition(); /*创建代表生产者方面的Condition对象*/ private Condition condition_con=lock.newCondition(); /*使用同一个锁，创建代表消费者方面的Condition对象*/ public void set(String name)&#123; lock.lock();//锁住此语句与lock.unlock()之间的代码 try&#123; while(flag) condition_pro.await(); //生产者线程在conndition_pro对象上等待 this.name=name+&quot;---&quot;+count++; System.out.println(Thread.currentThread().getName()+&quot;...生产者...&quot;+this.name); flag=true; condition_con.signalAll(); &#125; finally&#123; lock.unlock(); //unlock()要放在finally块中。 &#125; &#125; public void out()&#123; lock.lock(); //锁住此语句与lock.unlock()之间的代码 try&#123; while(!flag) condition_con.await(); //消费者线程在conndition_con对象上等待 System.out.println(Thread.currentThread().getName()+&quot;...消费者...&quot;+this.name); flag=false; condition_pro.signqlAll(); /*唤醒所有在condition_pro对象下等待的线程，也就是唤醒所有生产者线程*/ &#125; finally&#123; lock.unlock(); &#125; &#125; &#125; 3、使用阻塞队列（BlockingQueue）控制线程通信 六、线程池newFixedThreadPool() ： 作用：该方法返回一个固定线程数量的线程池，该线程池中的线程数量始终不变，即不会再创建新的线程，也不会销毁已经创建好的线程，自始自终都是那几个固定的线程在工作，所以该线程池可以控制线程的最大并发数。栗子：假如有一个新任务提交时，线程池中如果有空闲的线程则立即使用空闲线程来处理任务，如果没有，则会把这个新任务存在一个任务队列中，一旦有线程空闲了，则按FIFO方式处理任务队列中的任务。 2、newCachedThreadPool() ： 作用：该方法返回一个可以根据实际情况调整线程池中线程的数量的线程池。即该线程池中的线程数量不确定，是根据实际情况动态调整的。栗子：假如该线程池中的所有线程都正在工作，而此时有新任务提交，那么将会创建新的线程去处理该任务，而此时假如之前有一些线程完成了任务，现在又有新任务提交，那么将不会创建新线程去处理，而是复用空闲的线程去处理新任务。那么此时有人有疑问了，那这样来说该线程池的线程岂不是会越集越多？其实并不会，因为线程池中的线程都有一个“保持活动时间”的参数，通过配置它，如果线程池中的空闲线程的空闲时间超过该“保存活动时间”则立刻停止该线程，而该线程池默认的“保持活动时间”为60s。 3、newSingleThreadExecutor() ： 作用：该方法返回一个只有一个线程的线程池，即每次只能执行一个线程任务，多余的任务会保存到一个任务队列中，等待这一个线程空闲，当这个线程空闲了再按FIFO方式顺序执行任务队列中的任务。 4、newScheduledThreadPool() ： 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。 5、newSingleThreadScheduledExecutor() ： 作用：该方法返回一个可以控制线程池内线程定时或周期性执行某任务的线程池。只不过和上面的区别是该线程池大小为1，而上面的可以指定线程池的大小。 execute(Runnable)这个方法接收一个Runnable实例，并且异步的执行 submit(Runnable)submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕 submit(Callable)submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。 1、Java8增强的ForkJoinPool产生线程池当需要处理递归分治算法时，考虑使用ForkJoinPool；仔细设置不再进行任务划分的阈值，这个阈值对性能有影响；Java 8中的一些特性会使用到ForkJoinPool中的通用线程池。在某些场合下，需要调整该线程池的默认的线程数量。 七、死锁（1）死锁的四个必要条件互斥条件：资源不能被共享，只能被同一个进程使用请求与保持条件：已经得到资源的进程可以申请新的资源非剥夺条件：已经分配的资源不能从相应的进程中被强制剥夺循环等待条件：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程占用的资源 线程离开运行状态的3种方法： 1、调用Thread.sleep()：使当前线程睡眠至少多少毫秒（尽管它可能在指定的时间之前被中断）。 2、调用Thread.yield()：不能保障太多事情，尽管通常它会让当前运行线程回到可运行性状态，使得有相同优先级的线程有机会执行。 3、调用join()方法：保证当前线程停止执行，直到该线程所加入的线程完成为止。然而，如果它加入的线程没有存活，则当前线程不需要停止。]]></content>
      <categories>
        <category>Thread</category>
      </categories>
      <tags>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jenkins]]></title>
    <url>%2F2019%2F06%2F12%2Fjenkins%2F</url>
    <content type="text"><![CDATA[jenkins+github自动部署项目遇到的问题 jenkins重启命令service jenkins restart jenkins构建项目后会杀死字进程解决办法export BUILD_ID=dontKillMenohup java -jar /home/cloud/run/spring-boot-0.0.1-SNAPSHOT.jar &gt;/dev/null 2&gt;&amp;1 &amp;sleep 10s]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis学习]]></title>
    <url>%2F2019%2F05%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[刚开始使用redis，记录一些东西，可能有点杂 Redis为什么使用单进程单线程方式也这么快1完全基于内存2采用单线程,避免了不必要的上下文切换和竞争条件3使用多路 I/O 复用模型 redis的内部实现内部实现采用epoll参考文章http://yaocoder.blog.51cto.com/2668309/888374 多路 I/O 复用和多线程IO有什么区别呢1.CPU本来就是线性的不论什么都需要顺序处理并行只能是多核CPU2.跟多线程相比较,线程切换需要切换到内核进行线程切换,需要消耗时间和资源.而I/O多路复用不需要切换线/进程,效率相对较高,特别是对高并发的应用nginx就是用I/O多路复用,故而性能极佳.但多线程编程逻辑和处理上比I/O多路复用简单.而I/O多路复用处理起 IO 多路复用是5种I/O模型中的第3种，对各种模型讲个故事，描述下区别：故事情节为：老李去买火车票，三天后买到一张退票。参演人员（老李，黄牛，售票员，快递员），往返车站耗费1小时。 1.阻塞I/O模型 老李去火车站买票，排队三天买到一张退票。 耗费：在车站吃喝拉撒睡 3天，其他事一件没干。 2.非阻塞I/O模型 老李去火车站买票，隔12小时去火车站问有没有退票，三天后买到一张票。 耗费：往返车站6次，路上6小时，其他时间做了好多事。 3.I/O复用模型 1.select/poll 老李去火车站买票，委托黄牛，然后每隔6小时电话黄牛询问，黄牛三天内买到票，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，打电话17次 2.epoll 老李去火车站买票，委托黄牛，黄牛买到后即通知老李去领，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，黄牛手续费100元，无需打电话 4.信号驱动I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李，然后老李去火车站交钱领票。 耗费：往返车站2次，路上2小时，免黄牛费100元，无需打电话 5.异步I/O模型 老李去火车站买票，给售票员留下电话，有票后，售票员电话通知老李并快递送票上门。 耗费：往返车站1次，路上1小时，免黄牛费100元，无需打电话 redisTemplate apihttps://docs.spring.io/spring-data/redis/docs/current/api/org/springframework/data/redis/core/RedisTemplate.html#restore-K-byte:A-long-java.util.concurrent.TimeUnit- 还在持续记录中]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
</search>
